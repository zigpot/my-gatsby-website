"use strict";(self.webpackChunkmy_gatsby_site=self.webpackChunkmy_gatsby_site||[]).push([[439],{6976:function(e,t,n){var a=n(1151),l=n(7294);function r(e){const t=Object.assign({p:"p",a:"a",img:"img",h2:"h2",pre:"pre",code:"code",em:"em",ul:"ul",li:"li"},(0,a.a)(),e.components);return l.createElement(l.Fragment,null,l.createElement(t.p,null,"Gas sensors are electronic components that undergo change in physical characteristic (such as resistivity) in the presence of certain gases in the atmosphere. Gas sensors have many applications, from gas leakage early warning system, air quality monitor, to ",l.createElement(t.a,{href:"https://ijaseit.insightsociety.org/index.php?option=com_content&view=article&id=9&Itemid=1&article_id=1659"},"electronic noses"),". In this article we'll be using Arduino and a gas sensor (",l.createElement(t.a,{href:"https://www.figarosensor.com/product/feature/combustible-gas-sensors.html"},"TG2600"),") to measure methane concentration in the air."),"\n",l.createElement(t.img,{src:"https://zigpot.files.wordpress.com/2021/09/tgs2600_1.jpg?w=500",alt:""}),"\n",l.createElement(t.p,null,"TGS2600"),"\n",l.createElement(t.h2,null,"finding the equation"),"\n",l.createElement(t.p,null,"Every sensor has it's own characteristics. Characteristics of sensors include sensitivity, resolution, linearity, etc. Knowing the sensor's characteristics allows us to map a certain value from the sensor to a physical condition, in our case, the concentration of a certain gas."),"\n",l.createElement(t.p,null,"These characteristics of sensor is usually specified in the manufacturer's datasheet. ",l.createElement(t.a,{href:"https://www.figarosensor.com/product/docs/TGS2600B00%20(0913).pdf"},"Here")," is the datasheet for TGS2600. At the bottom of the first page is this graph:"),"\n",l.createElement(t.img,{src:"https://zigpot.files.wordpress.com/2021/09/sensitivity.png?w=500",alt:""}),"\n",l.createElement(t.p,null,"A graphic representation like that isn't particularly suitable for implementation. A better way would be knowing the equation first. After choosing a gas we need pin some coordinate points along the graphic line. For instance, if we choose methane, we can pick some points on methane's line which is going to look like this:"),"\n",l.createElement("table",null,l.createElement("tbody",null,l.createElement("tr",null,l.createElement("td",null,"R",l.createElement("sub",null,"s"),"/R",l.createElement("sub",null,"o")),l.createElement("td",null,"Gas Concentration (ppm)")),l.createElement("tr",null,l.createElement("td",null,"1"),l.createElement("td",null,"3")),l.createElement("tr",null,l.createElement("td",null,"0.95"),l.createElement("td",null,"5")),l.createElement("tr",null,l.createElement("td",null,"0.9"),l.createElement("td",null,"10")),l.createElement("tr",null,l.createElement("td",null,"0.8"),l.createElement("td",null,"30")),l.createElement("tr",null,l.createElement("td",null,"0.75"),l.createElement("td",null,"40")),l.createElement("tr",null,l.createElement("td",null,"0.7"),l.createElement("td",null,"80")))),"\n",l.createElement(t.p,null,"Now we're ready to find an equation. We can use any tools that accommodate power regression such as a calculators, R Studio, or even spreadsheet software (my lecturer actually uses this!). Python is simple and ubiquitous, so let's use that."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"from scipy.optimize import curve_fit\nimport matplotlib.pyplot as plt\n\nx = [1, 0.95, 0.9, 0.8, 0.75, .7] #Rs/Ro\ny = [3, 5, 10, 30, 40, 80] #ppm\n")),"\n",l.createElement(t.p,null,"Notice that our input is the resistance and the output is the concentration, hence Rs/Ro as the ",l.createElement(t.em,null,"x")," axis, and ppm as the ",l.createElement(t.em,null,"y")," axis. Let's try put the data points back on a log-log scale."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"x = [1, 0.95, 0.9, 0.8, 0.75, .7] #Rs/Ro\ny = [ 3, 5, 10, 30, 40, 80] #ppm\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.xlabel('xlabel')\nplt.ylabel('ylabel')\nplt.scatter(x, y, c= 'red', alpha = 0.8, s = 18)\nplt.legend()\nplt.show()\n")),"\n",l.createElement(t.img,{src:"https://zigpot.files.wordpress.com/2021/09/scatter.png?w=500",alt:""}),"\n",l.createElement(t.p,null,"We should see quite obviously, that the regression line will have a negative slope (as x increases, y decreases). With b being a positive number, our equation should be given below:"),"\n",l.createElement(t.img,{src:"https://zigpot.files.wordpress.com/2021/09/codecogseqn1.png?w=500",alt:""}),"\n",l.createElement(t.p,null,"Scipy has a nice method called optimize.curve_fit which allows us to perform non-linear regression on a set of data points, given a function model. So that's it, we'll use curve_fit and feed it with our data x and y, and also throw our equation above in as an anonymous function (also known as a lambda)."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"popt, pcov = curve_fit(lambda fx,a,b: a*fx**-b,  x,  y)\nx_linspace = np.linspace(min(x), max(x), 100)\npower_y = popt[0]*x_linspace**-popt[1]\nplt.scatter(x, y, label='data points', c= 'red', alpha = 0.5, s = 18)\nplt.plot(x, power_y, label='power fit regression')\nplt.legend()\nplt.show()\n")),"\n",l.createElement(t.p,null,"This performs power fit regression on the data, as seen below:"),"\n",l.createElement(t.img,{src:"https://zigpot.files.wordpress.com/2021/09/powerfit-3.png?w=500",alt:""}),"\n",l.createElement(t.p,null,"That was sufficient as we only need an equation. However if the power fit isn't smooth enough, for the sake of graphical representation of our equation, we can use NumPy, to generate more points to represent the regression. That'll render a smoother appearance to our line."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"import numpy as np\n\nx = [1, 0.95, 0.9, 0.8, 0.75, .7]\ny = [3, 5, 10, 30, 40, 80]\npopt, pcov = curve_fit(lambda fx,a,b: a*fx**-b,  x,  y)\nx_linspace = np.linspace(min(x), max(x), 100)\npower_y = popt[0]*x_linspace**-popt[1]\n\nplt.xlabel('rs/ro')\nplt.ylabel('concentration (ppm)')\nplt.scatter(x, y, label='data points', c= 'red', alpha = 0.5, s = 18)\nplt.plot(x_linspace, power_y, label='power fit regression (smooth)')\nplt.legend()\nplt.show()\n")),"\n",l.createElement(t.img,{src:"https://zigpot.files.wordpress.com/2021/09/powerfitsmooth-1.png?w=500",alt:""}),"\n",l.createElement(t.p,null,"Back to the equation, we need to know the value of a and b. This was returned by curve_fit as an array with two elements (we named it popt):"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"print('The regressions equation is {:.2f}x^-{:.2f}'\n.format(popt[0],popt[1]))\n")),"\n",l.createElement(t.p,null,"That would give us:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"The regressions equation is 3.92x^-8.42\n")),"\n",l.createElement(t.h2,null,"the circuit (simple volt divider)"),"\n",l.createElement(t.p,null,"The electronic circuit below explains TGS2600 operational configuration. There are three resistive points:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,"RH: an isolated resistive element for heating. This heater is voltage supplied by VH."),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,"RS: our sensor's variable resistor. This is the part that changes it's resistance according to gas concentration."),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,"RL: load resistance."),"\n"),"\n"),"\n",l.createElement(t.img,{src:"https://zigpot.files.wordpress.com/2021/09/the-tgs-2600-gas-sensor-a-the-characteristics-and-b-its-electrical-circuit-10_w640.jpg?w=500",alt:""}),"\n",l.createElement(t.p,null,"This is how it works:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,"This circuit act as a basic voltage divider. Knowing the voltage output (VRL) and load resistor RL allows us to know the sensor resistance (RS) as shown by the equation above."),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,"RS in our circuit denotes the sensor resistor. However, in terms of resistance, RS is the resistance when a contaminant (Methane, CO, Iso-butane, etc) exists in the air. In the absence of contaminants in the air, the resistance is called RO. This baseline resistance (RO) has to be known prior to performing any operations. The calibration is performed by blowing fresh air onto the sensor (cleaning any remaining contaminants) and measuring the value of RS in a clean environment."),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,"We can compare previously measured RO to currently measured RS as a ratio and plug it in to our non-linear equation to obtain the value of gas concentration (ppm) in the air."),"\n"),"\n"),"\n",l.createElement(t.p,null,"Now let's solve:"),"\n",l.createElement(t.img,{src:"https://zigpot.files.wordpress.com/2021/09/codecogseqn3.png?w=500",alt:""}),"\n",l.createElement(t.img,{src:"https://zigpot.files.wordpress.com/2021/09/codecogseqn4.png?w=500",alt:""}),"\n",l.createElement(t.p,null,"And plug it into the regression formula:"),"\n",l.createElement(t.img,{src:"https://zigpot.files.wordpress.com/2021/09/codecogseqn5.png?w=500",alt:""}),"\n",l.createElement(t.h2,null,"knowing the limits"),"\n",l.createElement(t.p,null,"As we have seen in the graph above, the graph line only spans from 1 to 100 ppm. This is the range in which our sensor performs effectively, according to our manufacturer. Any value of RS/R0 that corresponds outside this range will be simply rejected for further measuring."),"\n",l.createElement(t.p,null,"To get the limits (the minimum and maximum value), we can simply invert our regression equation, and plug in the corresponding value of 1 and 100 respectively."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,'print("min value = {}".format(pow(1/popt[0],1/popt[1])))\nprint("max value = {}".format(pow(100/popt[0],1/popt[1])))\n')),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"min value = 0.8501540319805124\nmax value = 1.4691487900527789\n")),"\n",l.createElement(t.h2,null,"writing the code"),"\n",l.createElement(t.p,null,"Now let's program our Arduino! We assume the circuit has been build according to the specification (5V operating voltage etc.) so all we need to do right now is plugging the output of VRL to an analog pin. Let's choose A1 as our pin. Also let's name all of the variables we have acquired previously."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"const int sensorInputPin = A1;\nconst int r_load = 33000;\nlong r_zero = 41763;\nconst float X_min = 0.850;\nconst float X_max = 1.469;\nconst float a = 3.92;\nconst float b = -8.42;\n\nvoid setup() {\n  pinMode(sensorInputPin, INPUT);\n  Serial.begin(9600);\n}\n")),"\n",l.createElement(t.p,null,"As our input will be dividing the maximum value of the analog input (1024), we don't need to convert them to voltage. We can then write our equation down and sort out every value that exceeds the limit."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,'void loop() {\n  int rawInput = analogRead(sensorInputPin);\n  long r_sensor = ((1024.0 * r_load) / rawInput) - r_load;\n  float rSrO = (float)rS / (float)rO;\n  if (rSrO > X_max) Serial.println("Out of range (above 100 ppm).");\n  else if(rSrO < X_min) Serial.println("Out of range (below 1 ppm).");\n  else{\n    float ppm = a * pow((float)rS / (float)rO, b);\n    Serial.print("gas concentration: ");\n    Serial.print(ppm);\n    Serial.println(" ppm");\n  }\n  delay(1000);\n}\n')),"\n",l.createElement(t.p,null,"Check out the full code on my ",l.createElement(t.a,{href:"https://github.com/zigpot/tgs2600-on-arduino/"},"GitHub"),"."))}t.Z=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.a)(),e.components);return t?l.createElement(t,e,l.createElement(r,e)):r(e)}},3608:function(e,t,n){n.r(t),n.d(t,{Head:function(){return c},default:function(){return m}});var a=n(6976),l=n(7294),r=n(72),o=n(9357),i=n(2020);const s=e=>{let{data:t,children:n}=e;return l.createElement(r.Z,{pageTitle:t.mdx.frontmatter.title},l.createElement("div",{className:"text-body"},l.createElement("div",{className:"text-author"},t.mdx.frontmatter.author),l.createElement("div",{className:"text-date"},(0,i.Z)(t.mdx.frontmatter.date)),n))},c=e=>{let{data:t}=e;return l.createElement(o.Z,{title:t.mdx.frontmatter.title})};function m(e){return l.createElement(s,e,l.createElement(a.Z,e))}},72:function(e,t,n){n.d(t,{Z:function(){return i}});var a=n(7294),l=n(1883),r="layout-module--nav-link-item--a5f0a",o="layout-module--nav-link-text--69cda";var i=e=>{let{pageTitle:t,children:n}=e;const i=(0,l.useStaticQuery)("3159585216");return a.createElement("div",{className:"layout-module--container--78b04"},a.createElement("header",{className:"layout-module--site-title--e4dea"},i.site.siteMetadata.title),a.createElement("nav",null,a.createElement("ul",{className:"layout-module--nav-links--1113b"},a.createElement("li",{className:r},a.createElement(l.Link,{to:"/",className:o},"Home")),a.createElement("li",{className:r},a.createElement(l.Link,{to:"/literatures",className:o},"Literatures")),a.createElement("li",{className:r},a.createElement(l.Link,{to:"/blog",className:o},"etc")),a.createElement("li",{className:r},a.createElement(l.Link,{to:"/terms",className:o},"Terms")),a.createElement("li",{className:r},a.createElement(l.Link,{to:"/about",className:o},"About")))),a.createElement("main",null,a.createElement("h1",{className:"layout-module--heading--f158c"},t),n),a.createElement("div",{style:{height:"40px",backgroundColor:"transparent",textAlign:"center",fontSize:"xx-small",paddingTop:"20px"},className:"footer-div"}))}},9357:function(e,t,n){var a=n(7294),l=n(1883);t.Z=e=>{let{title:t}=e;const n=(0,l.useStaticQuery)("3159585216");return a.createElement("title",null,t," | ",n.site.siteMetadata.title)}},2020:function(e,t){t.Z=e=>{var t=e.split("-");return new Date(t[0],t[1]-1,t[2]).toDateString()}},1151:function(e,t,n){n.d(t,{a:function(){return o}});var a=n(7294);const l={},r=a.createContext(l);function o(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}}}]);
//# sourceMappingURL=component---src-pages-literatures-mdx-frontmatter-slug-js-content-file-path-blog-setting-up-gas-sensor-for-microcontroller-index-mdx-cb99333aa0481fd6e017.js.map